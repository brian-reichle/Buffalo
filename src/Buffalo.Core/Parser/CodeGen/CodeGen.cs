// Copyright (c) Brian Reichle.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using Buffalo.Core.Common;
using Buffalo.Core.Parser.Configuration;

namespace Buffalo.Core.Parser
{
	sealed class CodeGen
	{
		public CodeGen(Config config, TableData data)
		{
			_config = config;
			_data = data;
		}

		public void Write(TextWriter writer)
		{
			writer.WriteLine("// <auto-generated />");
			writer.WriteLine("//------------------------------------------------------------------------------");
			writer.WriteLine("// This code is auto-generated.");
			writer.WriteLine("// Do not attempt to edit this file by hand, you could hurt yourself!");
			writer.WriteLine("//------------------------------------------------------------------------------");
			writer.WriteLine();
			writer.WriteLine("using System;");
			writer.WriteLine("using System.Collections.Generic;");
			writer.WriteLine("using System.Diagnostics;");

			if (_config.Manager.Trace)
			{
				writer.WriteLine("using System.Text;");
			}

			foreach (var cUsing in _config.Usings)
			{
				writer.Write("using Type_");
				writer.Write(cUsing.Label.Text);
				writer.Write(" = ");
				writer.Write(cUsing.ClassName.Text);
				writer.WriteLine(";");
			}

			writer.WriteLine();

			writer.Write("namespace ");
			writer.WriteLine(_config.Manager.ClassNamespace);

			writer.WriteLine("{");
			WriteParserTokenType(writer);
			writer.WriteLine();
			WriteParserClass(writer);
			writer.WriteLine("}");
		}

		public void WriteTableResource(Stream stream)
		{
			var size = _data.Actions.Bytes;
			var offset = 0;
			var buffer = new byte[Math.Min(size, 512)];

			while (offset < size)
			{
				var len = Math.Min(buffer.Length, size - offset);
				_data.Actions.CopyBytesTo(buffer, offset, len);
				stream.Write(buffer, 0, len);
				offset += len;
			}
		}

		void WriteParserTokenType(TextWriter writer)
		{
			writer.Write("	");
			writer.Write(_config.Manager.TypeVisibility == ClassVisibility.Public ? "public" : "internal");
			writer.Write(" enum ");
			writer.WriteLine(_config.Manager.TypeName);
			writer.WriteLine("	{");

			var labels = new string[_data.TerminalMap.Count];
			var indexes = new int[_data.TerminalMap.Count];
			var n = 0;
			var mask = _data.TerminalMask;
			var maskSize = BitOperations.PopulationCount(mask);

			foreach (var pair in _data.TerminalMap)
			{
				var i = pair.Value;

				labels[n] = pair.Key.Name;
				indexes[n] = i;
				n++;
			}

			Array.Sort(labels, indexes);

			for (var i = 0; i < labels.Length; i++)
			{
				writer.Write("		");
				writer.Write(labels[i]);
				writer.Write(" = ");

				var index = indexes[i];
				var column = index & mask;
				var subColumn = index >> maskSize;

				writer.Write(column);

				if (subColumn != 0)
				{
					writer.Write(" + (");
					writer.Write(subColumn);
					writer.Write(" << ");
					writer.Write(maskSize);
					writer.Write(')');
				}

				writer.WriteLine(",");
			}

			writer.WriteLine("	}");
		}

		void WriteParserClass(TextWriter writer)
		{
			var size = ElementSizeStrategy.Get(_config.Manager.ElementSize);

			writer.Write("	");
			writer.Write(_config.Manager.Visibility == ClassVisibility.Public ? "public" : "internal");
			writer.Write(" abstract class ");
			writer.WriteLine(_config.Manager.ParserName);
			writer.WriteLine("	{");

			if (_data.NeedsTerminalMask)
			{
				writer.Write("		const ");
				writer.Write(_config.Manager.TypeName);
				writer.Write(" ColumnMask = (");
				writer.Write(_config.Manager.TypeName);
				writer.Write(")");
				writer.Write(_data.TerminalMask);
				writer.WriteLine(";");
				writer.WriteLine();
			}

			WriteStatistics(writer, _data.Statistics, size);

			WriteParserConstructor(writer);
			writer.WriteLine();

			if (_config.Manager.Trace)
			{
				WriteTraceProperty(writer);
				writer.WriteLine();
			}

			foreach (var entryPoint in _config.EntryPoints)
			{
				WriteParseMethod(writer, entryPoint, _config.EntryPoints.Count != 1);
				writer.WriteLine();
			}

			WriteParseMethod(writer);
			writer.WriteLine();
			WriteReductionMethod(writer);
			writer.WriteLine();

			if (!_config.UseErrorRecovery)
			{
				WriteUnexpectedTokenMethod(writer);
			}
			else
			{
				WriteReduceErrorMethod(writer);
				writer.WriteLine();
				WriteCanBeFollowedBy(writer);
			}

			writer.WriteLine();

			foreach (var method in HelperMethod.GetDecompressionMethods(_data.Actions.Method, size, !string.IsNullOrEmpty(_config.TableResourceName)))
			{
				method.Write(writer, 2);
				writer.WriteLine();
			}

			writer.Write("		protected abstract ");
			writer.Write(_config.Manager.TypeName);
			writer.Write(" GetTokenType(Type_");
			writer.Write(_config.TerminalType.Label.Text);
			writer.WriteLine(" terminal);");
			writer.WriteLine();

			foreach (var method in GetAbstractMethods(_config))
			{
				WriteReductionMethod(writer, method);
			}

			if (_config.Manager.Trace)
			{
				writer.WriteLine();
				WriteTraceMethod(writer);
				writer.WriteLine();
				WriteReductionStringMethod(writer);
			}

			writer.WriteLine();
			WriteFields(writer, size);
			writer.WriteLine();
			WriteStateStruct(writer);
			writer.WriteLine();
			WriteTableCacheMembers(writer);
			writer.WriteLine("	}");
		}

		void WriteTraceMethod(TextWriter writer)
		{
			var maxTokenLen = 4;

			foreach (var terminal in _data.TerminalMap.Keys)
			{
				maxTokenLen = Math.Max(maxTokenLen, terminal.Name.Length);
			}

			writer.Write("		void WriteTrace(int state, ");
			writer.Write(_config.Manager.TypeName);
			writer.WriteLine(" type, string action)");
			writer.WriteLine("		{");
			writer.WriteLine("			if (_traceBuilder == null)");
			writer.WriteLine("			{");
			writer.WriteLine("				_traceBuilder = new StringBuilder();");
			writer.WriteLine("				_traceBuilder.AppendLine();");
			writer.Write("				_traceBuilder.AppendLine(\"State  | Type");
			writer.Write(new string(' ', maxTokenLen - 4));
			writer.WriteLine(" | Action\");");
			writer.Write("				_traceBuilder.AppendLine(\"-------+-");
			writer.Write(new string('-', maxTokenLen));
			writer.WriteLine("-+------------\");");
			writer.WriteLine("			}");
			writer.WriteLine();
			writer.WriteLine("			string stateStr = state.ToString();");
			writer.WriteLine("			string typeStr = type.ToString();");
			writer.WriteLine();
			writer.WriteLine("			_traceBuilder.Append(' ', 6 - stateStr.Length);");
			writer.WriteLine("			_traceBuilder.Append(stateStr);");
			writer.WriteLine("			_traceBuilder.Append(\" | \");");
			writer.WriteLine("			_traceBuilder.Append(typeStr);");
			writer.Write("			_traceBuilder.Append(' ', ");
			writer.Write(maxTokenLen);
			writer.WriteLine(" - typeStr.Length);");
			writer.WriteLine("			_traceBuilder.Append(\" | \");");
			writer.WriteLine("			_traceBuilder.AppendLine(action);");
			writer.WriteLine("		}");
		}

		void WriteReductionStringMethod(TextWriter writer)
		{
			writer.WriteLine("		string ReductionString(int reductionId)");
			writer.WriteLine("		{");
			writer.WriteLine("			switch (reductionId)");
			writer.WriteLine("			{");

			foreach (var cProduction in _config.Productions)
			{
				foreach (var cRule in cProduction.Rules)
				{
					var production = cRule.Production;

					if (_data.ReductionMap.TryGetValue(production, out var reductionId))
					{
						writer.Write("				case ");
						writer.Write(reductionId);
						writer.Write(": return \"");
						writer.Write(production.ToString());
						writer.WriteLine("\";");
					}
				}
			}

			writer.WriteLine("				default: throw new InvalidOperationException(\"unknown reduction\");");
			writer.WriteLine("			}");
			writer.WriteLine("		}");
		}

		static void WriteTraceProperty(TextWriter writer)
		{
			writer.WriteLine("		public string Trace");
			writer.WriteLine("		{");
			writer.WriteLine("			get { return _traceBuilder == null ? string.Empty : _traceBuilder.ToString(); }");
			writer.WriteLine("		}");
		}

		void WriteTableCacheMembers(TextWriter writer)
		{
			var size = _data.Actions.ElementSize;

			writer.Write("		static ");
			writer.Write(size.Keyword);
			writer.WriteLine("[] GetTransitionTable()");
			writer.WriteLine("		{");

			if (_config.Manager.CacheTables)
			{
				writer.Write("			");
				writer.Write(size.Keyword);
				writer.WriteLine("[] result;");
				writer.WriteLine();
				writer.WriteLine("			lock (_weakRef)");
				writer.WriteLine("			{");
				writer.Write("				if ((result = (");
				writer.Write(size.Keyword);
				writer.WriteLine("[])_weakRef.Target) == null)");
				writer.WriteLine("				{");
				writer.Write("					_weakRef.Target = result = ");

				if (string.IsNullOrEmpty(_config.TableResourceName))
				{
					CodeGenHelper.WriteLargeIntArray(writer, 5, 16, _data.Actions);
				}
				else
				{
					CodeGenHelper.WriteLargeIntArray(writer, _data.Actions.Method, _config.TableResourceName);
				}

				writer.WriteLine(";");
				writer.WriteLine("				}");
				writer.WriteLine("			}");
				writer.WriteLine();
				writer.WriteLine("			return result;");
				writer.WriteLine("		}");
				writer.WriteLine();
				writer.WriteLine("		[DebuggerBrowsable(DebuggerBrowsableState.Never)]");
				writer.WriteLine("		static readonly WeakReference _weakRef = new WeakReference(null);");
			}
			else
			{
				writer.Write("			return ");

				if (string.IsNullOrEmpty(_config.TableResourceName))
				{
					CodeGenHelper.WriteLargeIntArray(writer, 3, 16, _data.Actions);
				}
				else
				{
					CodeGenHelper.WriteLargeIntArray(writer, _data.Actions.Method, _config.TableResourceName);
				}

				writer.WriteLine(";");
				writer.WriteLine("		}");
			}
		}

		void WriteParserConstructor(TextWriter writer)
		{
			writer.Write("		protected ");
			writer.Write(_config.Manager.ParserName);
			writer.WriteLine("()");
			writer.WriteLine("		{");
			writer.WriteLine("			_transitionTable = GetTransitionTable();");
			writer.WriteLine("		}");
		}

		void WriteParseMethod(TextWriter writer, ConfigEntryPoint entryPoint, bool withName)
		{
			writer.Write("		public Type_");
			writer.Write(entryPoint.Using.Label.Text);
			writer.Write(" Parse");

			if (withName)
			{
				writer.Write('_');
				writer.Write(entryPoint.Segment.Name);
			}

			writer.Write("(IEnumerable<Type_");
			writer.Write(_config.TerminalType.Label.Text);
			writer.WriteLine("> tokens)");
			writer.WriteLine("		{");
			writer.Write("			return ");

			if (_config.Manager.TypeHandling == TypeHandling.Cast)
			{
				writer.Write("(Type_");
				writer.Write(entryPoint.Using.Label.Text);
				writer.Write(')');
			}

			var state = _config.Graph[entryPoint.Segment];

			writer.Write("Parse(tokens, ");
			writer.Write(_data.StateMap[state]);
			writer.Write(").value");

			if (_config.Manager.TypeHandling == TypeHandling.Field)
			{
				writer.Write('_');
				writer.Write(entryPoint.Using.Label.Text);
			}

			writer.WriteLine(";");
			writer.WriteLine("		}");
		}

		void WriteParseMethod(TextWriter writer)
		{
			writer.Write("		State Parse(IEnumerable<Type_");
			writer.Write(_config.TerminalType.Label.Text);
			writer.WriteLine("> tokens, int initialState)");
			writer.WriteLine("		{");
			writer.WriteLine("			List<State> stack = new List<State>();");
			writer.WriteLine();
			writer.WriteLine("			{");
			writer.WriteLine("				State init = new State();");
			writer.WriteLine("				init.state = initialState;");
			writer.WriteLine("				stack.Add(init);");
			writer.WriteLine("			}");
			writer.WriteLine();

			if (_config.Manager.Trace)
			{
				writer.WriteLine("			_traceBuilder = null;");
				writer.WriteLine();
			}

			writer.WriteLine("			int state = initialState;");
			writer.WriteLine();
			writer.Write("			using (IEnumerator<Type_");
			writer.Write(_config.TerminalType.Label.Text);
			writer.WriteLine("> enumerator = tokens.GetEnumerator())");
			writer.WriteLine("			{");
			writer.WriteLine("				bool haveToken = enumerator.MoveNext();");
			writer.WriteLine();
			writer.WriteLine("				while (haveToken)");
			writer.WriteLine("				{");
			writer.Write("					Type_");
			writer.Write(_config.TerminalType.Label.Text);
			writer.WriteLine(" token = enumerator.Current;");
			writer.Write("					");
			writer.Write(_config.Manager.TypeName);
			writer.WriteLine(" type = GetTokenType(token);");
			writer.WriteLine();

			if (_config.UseErrorRecovery)
			{
				writer.Write("					if (type == ");
				writer.Write(_config.Manager.TypeName);
				writer.Write(".");
				writer.Write(Segment.Error.Name);
				writer.WriteLine(")");
				writer.WriteLine("					{");
				writer.WriteLine("						state = ReduceError(stack, enumerator);");
				writer.WriteLine("					}");
				writer.WriteLine("					else");
			}

			writer.WriteLine("					{");
			writer.WriteLine("						int offset = _transitionTable[state];");
			writer.Write("						int action = offset <= ");
			writer.Write(_data.ReductionMap.Count + 1);
			writer.Write(" ? offset : _transitionTable[offset + (int)");

			if (_data.NeedsTerminalMask)
			{
				writer.Write("(type & ColumnMask)");
			}
			else
			{
				writer.Write("type");
			}

			writer.WriteLine("];");
			writer.WriteLine();
			writer.Write("						if (action > ");
			writer.Write(_data.ReductionMap.Count + 1);
			writer.WriteLine(")");
			writer.WriteLine("						{");

			if (_config.Manager.Trace)
			{
				writer.WriteLine("							WriteTrace(state, type, \"Shift\");");
				writer.WriteLine();
			}

			writer.WriteLine("							State newState = new State();");
			writer.Write("							newState.state = state = action - ");
			writer.Write(_data.ReductionMap.Count + 1);
			writer.WriteLine(";");
			writer.Write("							newState.value");

			if (_config.Manager.TypeHandling == TypeHandling.Field)
			{
				writer.Write('_');
				writer.Write(_config.TerminalType.Label.Text);
			}

			writer.WriteLine(" = token;");
			writer.WriteLine();
			writer.WriteLine("							stack.Add(newState);");
			writer.WriteLine("							haveToken = enumerator.MoveNext();");
			writer.WriteLine("						}");
			writer.WriteLine("						else if (action > 1)");
			writer.WriteLine("						{");
			writer.WriteLine("							int reductionId = action - 2;");

			if (_config.Manager.Trace)
			{
				writer.WriteLine("							WriteTrace(state, type, ReductionString(reductionId));");
			}

			writer.WriteLine("							state = Reduce(reductionId, stack);");
			writer.WriteLine("						}");
			writer.Write("						else if (action == 0 || type != ");
			writer.Write(_config.Manager.TypeName);
			writer.WriteLine(".EOF)");
			writer.WriteLine("						{");

			if (_config.Manager.Trace)
			{
				writer.WriteLine("							WriteTrace(state, type, \"Error\");");
			}

			if (!_config.UseErrorRecovery)
			{
				writer.WriteLine("							UnexpectedToken(token);");
				writer.WriteLine("							throw new InvalidOperationException(\"unexpected token: \" + type);");
			}
			else
			{
				writer.WriteLine("							state = ReduceError(stack, enumerator);");
			}

			writer.WriteLine("						}");
			writer.WriteLine("						else");
			writer.WriteLine("						{");

			if (_config.Manager.Trace)
			{
				writer.WriteLine("							WriteTrace(state, type, \"Accept\");");
			}

			writer.WriteLine("							return stack[1];");
			writer.WriteLine("						}");
			writer.WriteLine("					}");
			writer.WriteLine("				}");
			writer.WriteLine("			}");
			writer.WriteLine();
			writer.WriteLine("			throw new InvalidOperationException(\"ran out of tokens, somehow\");");
			writer.WriteLine("		}");
		}

		void WriteUnexpectedTokenMethod(TextWriter writer)
		{
			writer.Write("		protected virtual void UnexpectedToken(Type_");
			writer.Write(_config.TerminalType.Label.Text);
			writer.WriteLine(" terminal)");
			writer.WriteLine("		{");
			writer.WriteLine("		}");
		}

		void WriteReductionMethod(TextWriter writer)
		{
			writer.WriteLine("		int Reduce(int reductionId, List<State> stack)");
			writer.WriteLine("		{");
			writer.WriteLine("			State newState = new State();");
			writer.WriteLine("			int gotoIndex;");
			writer.WriteLine();
			writer.WriteLine("			switch (reductionId)");
			writer.WriteLine("			{");

			var commandWriter = new CommandWriter(writer, _config);

			foreach (var cProduction in _config.Productions)
			{
				foreach (var cRule in cProduction.Rules)
				{
					var production = cRule.Production;

					if (_data.ReductionMap.TryGetValue(production, out var index))
					{
						var gotoIndex = _data.GotoMap[production.Target];

						writer.Write("				case ");
						writer.Write(index);
						writer.Write(": // ");
						writer.WriteLine(production.ToString());

						writer.Write("					newState.value");

						if (_config.Manager.TypeHandling == TypeHandling.Field)
						{
							writer.Write('_');
							writer.Write(cProduction.Using.Label.Text);
						}

						writer.Write(" = ");
						commandWriter.Write(cRule.Command, production);
						writer.WriteLine(";");
						writer.Write("					gotoIndex = ");
						writer.Write(gotoIndex);
						writer.WriteLine(";");

						if (production.Segments.Length > 1)
						{
							writer.Write("					stack.RemoveRange(stack.Count - ");
							writer.Write(production.Segments.Length);
							writer.Write(", ");
							writer.Write(production.Segments.Length);
							writer.WriteLine(");");
						}
						else if (production.Segments.Length == 1)
						{
							writer.WriteLine("					stack.RemoveAt(stack.Count - 1);");
						}

						writer.WriteLine("					break;");
						writer.WriteLine();
					}
				}
			}

			writer.WriteLine("				default: throw new InvalidOperationException(\"unknown reduction\");");
			writer.WriteLine("			}");
			writer.WriteLine();
			writer.WriteLine("			int state = stack[stack.Count - 1].state;");
			writer.Write("			newState.state = _transitionTable[_transitionTable[state + ");
			writer.Write(_data.StateMap.Count);
			writer.WriteLine("] + gotoIndex];");
			writer.WriteLine();
			writer.WriteLine("			stack.Add(newState);");
			writer.WriteLine();
			writer.WriteLine("			return newState.state;");
			writer.WriteLine("		}");
		}

		void WriteReduceErrorMethod(TextWriter writer)
		{
			writer.Write("		int ReduceError(List<State> stack, IEnumerator<Type_");
			writer.Write(_config.TerminalType.Label.Text);
			writer.WriteLine("> enumerator)");
			writer.WriteLine("		{");
			writer.Write("			Type_");
			writer.Write(_config.TerminalType.Label.Text);
			writer.WriteLine(" errorToken = enumerator.Current;");
			writer.WriteLine();
			writer.Write("			if (GetTokenType(enumerator.Current) != ");
			writer.Write(_config.Manager.TypeName);
			writer.WriteLine(".EOF)");
			writer.WriteLine("			{");

			if (_config.Manager.Trace)
			{
				writer.WriteLine("				WriteTrace(stack[stack.Count - 1].state, GetTokenType(errorToken), \"Discard Token\");");
				writer.WriteLine();
			}

			writer.WriteLine("				if (!enumerator.MoveNext())");
			writer.WriteLine("				{");
			writer.WriteLine("					throw new InvalidOperationException(\"ran out of tokens while attempting to recover from a parse error.\");");
			writer.WriteLine("				}");
			writer.WriteLine("			}");
			writer.WriteLine();
			writer.Write("			bool[] failed = new bool[");
			writer.Write(_data.TerminalColumns);
			writer.WriteLine("];");
			writer.WriteLine();
			writer.WriteLine("			do");
			writer.WriteLine("			{");
			writer.WriteLine("				int state = stack[stack.Count - 1].state;");
			writer.WriteLine("				int offset = _transitionTable[state];");
			writer.Write("				int action = offset <= ");
			writer.Write(_data.ReductionMap.Count + 1);
			writer.Write(" ? offset : _transitionTable[offset + (int)");

			if (_data.NeedsTerminalMask)
			{
				writer.Write('(');
				writer.Write(_config.Manager.TypeName);
				writer.Write(".Error & ColumnMask)");
			}
			else
			{
				writer.Write(_config.Manager.TypeName);
				writer.Write(".Error");
			}

			writer.WriteLine("];");
			writer.WriteLine();
			writer.Write("				if (action == 0 || action > ");
			writer.Write(_data.ReductionMap.Count + 1);
			writer.WriteLine(")");
			writer.WriteLine("				{");
			writer.WriteLine("					break;");
			writer.WriteLine("				}");
			writer.WriteLine("				else");
			writer.WriteLine("				{");
			writer.WriteLine("					int reductionId = action - 2;");

			if (_config.Manager.Trace)
			{
				writer.Write("					WriteTrace(state, ");
				writer.Write(_config.Manager.TypeName);
				writer.WriteLine(".Error, ReductionString(reductionId));");
			}

			writer.WriteLine("					state = Reduce(reductionId, stack);");
			writer.WriteLine("				}");
			writer.WriteLine("			}");
			writer.WriteLine("			while (true);");
			writer.WriteLine();
			writer.WriteLine("			do");
			writer.WriteLine("			{");
			writer.Write("				");
			writer.Write(_config.Manager.TypeName);
			writer.WriteLine(" nextType = GetTokenType(enumerator.Current);");
			writer.WriteLine();
			writer.Write("				if (!failed[(int)");

			if (_data.NeedsTerminalMask)
			{
				writer.Write("(nextType & ColumnMask)");
			}
			else
			{
				writer.Write("nextType");
			}

			writer.WriteLine("])");
			writer.WriteLine("				{");
			writer.WriteLine("					for (int i = stack.Count - 1; i >= 0; i--)");
			writer.WriteLine("					{");
			writer.WriteLine("						int state = stack[i].state;");
			writer.WriteLine("						int offset = _transitionTable[state];");
			writer.Write("						if (offset <= ");
			writer.Write(_data.ReductionMap.Count + 1);
			writer.WriteLine(") continue;");
			writer.WriteLine();
			writer.Write("						int action = _transitionTable[offset + (int)");

			if (_data.NeedsTerminalMask)
			{
				writer.Write('(');
				writer.Write(_config.Manager.TypeName);
				writer.Write(".Error & ColumnMask)");
			}
			else
			{
				writer.Write(_config.Manager.TypeName);
				writer.Write(".Error");
			}

			writer.Write("] - ");
			writer.Write(_data.ReductionMap.Count + 1);
			writer.WriteLine(";");
			writer.WriteLine();
			writer.WriteLine("						if (action <= 0) continue;");
			writer.WriteLine("						if (!CanBeFollowedBy(stack, i, action, nextType)) continue;");
			writer.WriteLine();
			writer.WriteLine("						State newState = new State();");
			writer.WriteLine("						newState.state = action;");
			writer.Write("						newState.value");

			if (_config.Manager.TypeHandling == TypeHandling.Field)
			{
				writer.Write('_');
				writer.Write(_config.TerminalType.Label.Text);
			}

			writer.WriteLine(" = errorToken;");
			writer.WriteLine();

			if (_config.Manager.Trace)
			{
				writer.WriteLine("						WriteTrace(state, nextType, string.Format(\"Discard {0} state(s)\", stack.Count - i - 1));");
				writer.WriteLine();
			}

			writer.WriteLine("						stack.RemoveRange(i + 1, stack.Count - i - 1);");
			writer.WriteLine("						stack.Add(newState);");
			writer.WriteLine("						return action;");
			writer.WriteLine("					}");
			writer.WriteLine();
			writer.Write("					failed[(int)");

			if (_data.NeedsTerminalMask)
			{
				writer.Write("(nextType & ColumnMask)");
			}
			else
			{
				writer.Write("nextType");
			}

			writer.WriteLine("] = true;");
			writer.WriteLine("				}");
			writer.WriteLine();
			writer.Write("				if (nextType == ");
			writer.Write(_config.Manager.TypeName);
			writer.WriteLine(".EOF)");
			writer.WriteLine("				{");
			writer.WriteLine("					throw new InvalidOperationException(\"unexpected token: \" + GetTokenType(errorToken));");
			writer.WriteLine("				}");

			if (_config.Manager.Trace)
			{
				writer.WriteLine();
				writer.WriteLine("				WriteTrace(stack[stack.Count - 1].state, nextType, \"Discard Token\");");
			}

			writer.WriteLine("			}");
			writer.WriteLine("			while (enumerator.MoveNext());");
			writer.WriteLine();
			writer.WriteLine("			throw new InvalidOperationException(\"ran out of tokens while attempting to recover from a parse error.\");");
			writer.WriteLine("		}");
		}

		void WriteCanBeFollowedBy(TextWriter writer)
		{
			writer.Write("		bool CanBeFollowedBy(List<State> stack, int tosIndex, int startState, ");
			writer.Write(_config.Manager.TypeName);
			writer.WriteLine(" type)");
			writer.WriteLine("		{");
			writer.WriteLine("			List<int> overStack = new List<int>();");
			writer.WriteLine("			overStack.Add(startState);");
			writer.WriteLine();
			writer.WriteLine("			int state = startState;");
			writer.WriteLine();
			writer.WriteLine("			while (true)");
			writer.WriteLine("			{");
			writer.WriteLine("				int offset = _transitionTable[state];");
			writer.Write("				int action = offset <= ");
			writer.Write(_data.ReductionMap.Count + 1);
			writer.Write(" ? offset : _transitionTable[offset + (int)");

			if (_data.NeedsTerminalMask)
			{
				writer.Write("(type & ColumnMask)");
			}
			else
			{
				writer.Write("type");
			}

			writer.WriteLine("];");
			writer.WriteLine();
			writer.WriteLine("				if (action == 0) return false;");
			writer.Write("				if (action > ");
			writer.Write(_data.ReductionMap.Count + 1);
			writer.WriteLine(" || action == 1) return true;");
			writer.WriteLine();
			writer.WriteLine("				int count;");
			writer.WriteLine("				int gotoIndex;");
			writer.WriteLine();
			writer.WriteLine("				switch (action - 2)");
			writer.WriteLine("				{");

			foreach (var cProduction in _config.Productions)
			{
				foreach (var cRule in cProduction.Rules)
				{
					var production = cRule.Production;

					if (_data.ReductionMap.TryGetValue(production, out var reductionId))
					{
						writer.Write("					case ");
						writer.Write(reductionId);
						writer.Write(": // ");
						writer.WriteLine(production.ToString());
						writer.Write("						count = ");
						writer.Write(production.Segments.Length);
						writer.WriteLine(";");
						writer.Write("						gotoIndex = ");
						writer.Write(_data.GotoMap[production.Target]);
						writer.WriteLine(";");
						writer.WriteLine("						break;");
						writer.WriteLine();
					}
				}
			}

			writer.WriteLine("					default: throw new InvalidOperationException(\"unknown reduction\");");
			writer.WriteLine("				}");
			writer.WriteLine();
			writer.WriteLine("				if (count >= overStack.Count)");
			writer.WriteLine("				{");
			writer.WriteLine("					tosIndex = tosIndex - count + overStack.Count;");
			writer.WriteLine("					overStack.Clear();");
			writer.WriteLine();
			writer.WriteLine("					state = stack[tosIndex].state;");
			writer.WriteLine("				}");
			writer.WriteLine("				else if (count > 0)");
			writer.WriteLine("				{");
			writer.WriteLine("					overStack.RemoveRange(overStack.Count - count, count);");
			writer.WriteLine();
			writer.WriteLine("					state = overStack[overStack.Count - 1];");
			writer.WriteLine("				}");
			writer.WriteLine();
			writer.Write("				overStack.Add(state = _transitionTable[_transitionTable[state + ");
			writer.Write(_data.StateMap.Count);
			writer.WriteLine("] + gotoIndex]);");
			writer.WriteLine("			}");
			writer.WriteLine("		}");
		}

		static void WriteReductionMethod(TextWriter writer, ConfigCommandMethod method)
		{
			writer.Write("		protected abstract Type_");
			writer.Write(method.Using.Label.Text);
			writer.Write(' ');
			writer.Write(method.Name.Text);
			writer.Write('(');

			var paramNames = GetParamNames(method);

			if (method.Arguments.Count > 0)
			{
				WriteSegmentType(writer, method.Arguments[0]);
				writer.Write(' ');
				writer.Write(paramNames[0]);

				for (var i = 1; i < method.Arguments.Count; i++)
				{
					writer.Write(", ");
					WriteSegmentType(writer, method.Arguments[i]);
					writer.Write(' ');
					writer.Write(paramNames[i]);
				}
			}

			writer.WriteLine(");");
		}

		static void WriteSegmentType(TextWriter writer, ConfigCommand command)
		{
			writer.Write("Type_");
			writer.Write(command.Using.Label.Text);
		}

		void WriteFields(TextWriter writer, ElementSizeStrategy elementSize)
		{
			writer.WriteLine("		[DebuggerBrowsable(DebuggerBrowsableState.Never)]");
			writer.Write("		readonly ");
			writer.Write(elementSize.Keyword);
			writer.WriteLine("[] _transitionTable;");

			if (_config.Manager.Trace)
			{
				writer.WriteLine("		[DebuggerBrowsable(DebuggerBrowsableState.Never)]");
				writer.WriteLine("		StringBuilder _traceBuilder;");
			}
		}

		static void WriteStatistics(TextWriter writer, Statistics statistics, ElementSizeStrategy elementSize)
		{
			var actionsNatural = statistics.States * (statistics.TerminalColumns + statistics.NonTerminalColumns);

			writer.WriteLine("		// [Statistics]");
			writer.Write("		// Reductions          : ");
			writer.WriteLine(statistics.Reductions);
			writer.Write("		// Terminals           : ");
			writer.Write(statistics.Terminals);
			writer.Write(" (");
			writer.Write(statistics.TerminalColumns);
			writer.WriteLine(statistics.TerminalColumns == 1 ? " column)" : " columns)");
			writer.Write("		// NonTerminals        : ");
			writer.Write(statistics.NonTerminals);
			writer.Write(" (");
			writer.Write(statistics.NonTerminalColumns);
			writer.WriteLine(statistics.NonTerminalColumns == 1 ? " column)" : " columns)");
			writer.Write("		// States              : ");
			writer.WriteLine(statistics.States);
			writer.Write("		//   Short Circuited   : ");
			writer.WriteLine(statistics.StatesShortCircuited);
			writer.Write("		//   With Goto Entries : ");
			writer.WriteLine(statistics.StatesWithGotos);
			writer.Write("		//   With SR Conflicts : ");
			writer.WriteLine(statistics.StatesWithSRConflicts);
			writer.Write("		//   Other             : ");
			writer.WriteLine(statistics.StatesOther);
			writer.Write("		// Transition Table    : ");
			writer.Write(statistics.ActionsRunTime);
			writer.Write("/");
			writer.Write(actionsNatural);
			writer.Write("(");
			writer.Write(((statistics.ActionsRunTime / (decimal)actionsNatural) * 100).ToString("0.00", CultureInfo.InvariantCulture));
			writer.WriteLine("%)");
			writer.Write("		//   Primary Offsets   : ");
			writer.WriteLine(statistics.States);
			writer.Write("		//   Goto Offsets      : ");
			writer.WriteLine(statistics.GotoOffsetsLen);
			writer.Write("		//   Actions           : ");
			writer.WriteLine(statistics.ActionsRunTime - statistics.States - statistics.GotoOffsetsLen);

			var actionsBytes = elementSize.Size(statistics.ActionsRunTime);
			var assemblyBytes = statistics.ActionsAssemblyBytes;

			writer.Write("		// Memory Footprint    : ");
			writer.Write(actionsBytes);
			writer.WriteLine(" bytes");
			writer.Write("		// Assembly Footprint  : ");
			writer.Write(assemblyBytes);
			writer.Write(" bytes (");
			writer.Write(((assemblyBytes / (decimal)actionsBytes) * 100).ToString("0.00", CultureInfo.InvariantCulture));
			writer.WriteLine("%)");
		}

		void WriteStateStruct(TextWriter writer)
		{
			writer.WriteLine("		struct State");
			writer.WriteLine("		{");
			writer.WriteLine("			public int state;");

			switch (_config.Manager.TypeHandling)
			{
				case TypeHandling.Field:
					foreach (var cUsing in _config.Usings)
					{
						writer.Write("			public Type_");
						writer.Write(cUsing.Label.Text);
						writer.Write(" value_");
						writer.Write(cUsing.Label.Text);
						writer.WriteLine(";");
					}

					break;

				case TypeHandling.Cast:
					writer.WriteLine("			public object value;");
					break;
			}

			writer.WriteLine("		}");
		}

		static string[] GetParamNames(ConfigCommandMethod method)
		{
			var lookup = new Dictionary<string, List<int>>();

			for (var i = 0; i < method.Arguments.Count; i++)
			{
				var argument = method.Arguments[i];
				var segmentName = argument.Segment.Name;

				var name = CamelCase(segmentName) + "Seg";

				if (!lookup.TryGetValue(name, out var list))
				{
					list = new List<int>();
					lookup.Add(name, list);
				}

				list.Add(i);
			}

			var result = new string[method.Arguments.Count];

			foreach (var pair in lookup)
			{
				if (pair.Value.Count == 1)
				{
					result[pair.Value[0]] = pair.Key;
				}
				else
				{
					for (var i = 0; i < pair.Value.Count; i++)
					{
						result[pair.Value[i]] = pair.Key + (i + 1);
					}
				}
			}

			return result;
		}

		static string CamelCase(string inString)
		{
			if (inString.Length > 0 && char.IsUpper(inString, 0))
			{
				var builder = new StringBuilder(inString);
				builder[0] = char.ToLower(builder[0], CultureInfo.InvariantCulture);
				return builder.ToString();
			}
			else
			{
				return inString;
			}
		}

		static IEnumerable<ConfigCommandMethod> GetAbstractMethods(Config config)
		{
			var result = new List<ConfigCommandMethod>();

			foreach (var production in config.Productions)
			{
				foreach (var rule in production.Rules)
				{
					GetReferencedAbstractMethods(result, rule.Command);
				}
			}

			return result;
		}

		static void GetReferencedAbstractMethods(List<ConfigCommandMethod> list, ConfigCommand command)
		{
			if (command is ConfigCommandMethod method)
			{
				list.Add(method);

				foreach (var arg in method.Arguments)
				{
					GetReferencedAbstractMethods(list, arg);
				}
			}
		}

		readonly Config _config;
		readonly TableData _data;
	}
}
