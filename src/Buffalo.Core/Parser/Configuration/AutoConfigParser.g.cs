// <auto-generated />
//------------------------------------------------------------------------------
// This code is auto-generated.
// Do not attempt to edit this file by hand, you could hurt yourself!
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
using Type_Command = Buffalo.Core.Parser.Configuration.ConfigCommand;
using Type_Config = Buffalo.Core.Parser.Configuration.Config;
using Type_EntryPoint = Buffalo.Core.Parser.Configuration.ConfigEntryPoint;
using Type_Production = Buffalo.Core.Parser.Configuration.ConfigProduction;
using Type_Rule = Buffalo.Core.Parser.Configuration.ConfigRule;
using Type_Segment = Buffalo.Core.Parser.Configuration.ConfigSegment;
using Type_Setting = Buffalo.Core.Parser.Configuration.ConfigSetting;
using Type_Terminal = Buffalo.Core.Parser.Configuration.ConfigToken;
using Type_Using = Buffalo.Core.Parser.Configuration.ConfigUsing;

namespace Buffalo.Core.Parser.Configuration
{
	internal enum ConfigTokenType
	{
		ArgumentValue = 1,
		Assign = 4,
		Bang = 0,
		Becomes = 14,
		CloseBrace = 15,
		CloseParen = 16,
		Entry = 5,
		EOF = 11,
		Error = 8,
		Label = 10,
		NonTerminal = 9,
		Null = 18,
		OpenBrace = 13,
		OpenParen = 17,
		Pipe = 6,
		QuestionMark = 0 + (1 << 5),
		Semicolon = 7,
		String = 3,
		TargetValue = 2,
		Using = 12,
	}

	internal abstract class AutoConfigParser
	{
		const ConfigTokenType ColumnMask = (ConfigTokenType)31;

		// [Statistics]
		// Reductions          : 32
		// Terminals           : 20 (19 columns)
		// NonTerminals        : 13 (3 columns)
		// States              : 57
		//   Short Circuited   : 26
		//   With Goto Entries : 8
		//   With SR Conflicts : 8
		//   Other             : 22
		// Transition Table    : 450/1254(35.89%)
		//   Primary Offsets   : 57
		//   Goto Offsets      : 8
		//   Actions           : 385
		// Memory Footprint    : 900 bytes
		// Assembly Footprint  : 290 bytes (32.22%)
		protected AutoConfigParser()
		{
			_transitionTable = GetTransitionTable();
		}

		public Type_Config Parse(IEnumerable<Type_Terminal> tokens)
		{
			return Parse(tokens, 0).value_Config;
		}

		State Parse(IEnumerable<Type_Terminal> tokens, int initialState)
		{
			List<State> stack = new List<State>();

			{
				State init = new State();
				init.state = initialState;
				stack.Add(init);
			}

			int state = initialState;

			using (IEnumerator<Type_Terminal> enumerator = tokens.GetEnumerator())
			{
				bool haveToken = enumerator.MoveNext();

				while (haveToken)
				{
					Type_Terminal token = enumerator.Current;
					ConfigTokenType type = GetTokenType(token);

					if (type == ConfigTokenType.Error)
					{
						state = ReduceError(stack, enumerator);
					}
					else
					{
						int offset = _transitionTable[state];
						int action = offset <= 33 ? offset : _transitionTable[offset + (int)(type & ColumnMask)];

						if (action > 33)
						{
							State newState = new State();
							newState.state = state = action - 33;
							newState.value_Terminal = token;

							stack.Add(newState);
							haveToken = enumerator.MoveNext();
						}
						else if (action > 1)
						{
							int reductionId = action - 2;
							state = Reduce(reductionId, stack);
						}
						else if (action == 0 || type != ConfigTokenType.EOF)
						{
							state = ReduceError(stack, enumerator);
						}
						else
						{
							return stack[1];
						}
					}
				}
			}

			throw new InvalidOperationException("ran out of tokens, somehow");
		}

		int Reduce(int reductionId, List<State> stack)
		{
			State newState = new State();
			int gotoIndex;

			switch (reductionId)
			{
				case 5: // <Config> -> <Config> <Production>
					newState.value_Config = Reduce_Config_1(stack[stack.Count - 2].value_Config, stack[stack.Count - 1].value_Production);
					gotoIndex = 0;
					stack.RemoveRange(stack.Count - 2, 2);
					break;

				case 4: // <Config> -> <Config> Error
					newState.value_Config = Reduce_Config_2(stack[stack.Count - 2].value_Config, stack[stack.Count - 1].value_Terminal);
					gotoIndex = 0;
					stack.RemoveRange(stack.Count - 2, 2);
					break;

				case 1: // <Config> -> <ConfigSettings>
					newState.value_Config = stack[stack.Count - 1].value_Config;
					gotoIndex = 0;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 8: // <ConfigSettings> -> <ConfigSettings> <Setting>
					newState.value_Config = Reduce_ConfigSettings_1(stack[stack.Count - 2].value_Config, stack[stack.Count - 1].value_Setting);
					gotoIndex = 1;
					stack.RemoveRange(stack.Count - 2, 2);
					break;

				case 9: // <ConfigSettings> -> <ConfigSettings> <Using>
					newState.value_Config = Reduce_ConfigSettings_2(stack[stack.Count - 2].value_Config, stack[stack.Count - 1].value_Using);
					gotoIndex = 1;
					stack.RemoveRange(stack.Count - 2, 2);
					break;

				case 7: // <ConfigSettings> -> <ConfigSettings> <EntryPoint>
					newState.value_Config = Reduce_ConfigSettings_3(stack[stack.Count - 2].value_Config, stack[stack.Count - 1].value_EntryPoint);
					gotoIndex = 1;
					stack.RemoveRange(stack.Count - 2, 2);
					break;

				case 6: // <ConfigSettings> -> <ConfigSettings> Error
					newState.value_Config = Reduce_ConfigSettings_4(stack[stack.Count - 2].value_Config, stack[stack.Count - 1].value_Terminal);
					gotoIndex = 1;
					stack.RemoveRange(stack.Count - 2, 2);
					break;

				case 2: // <ConfigSettings> -> Error
					newState.value_Config = Reduce_ConfigSettings_5(stack[stack.Count - 1].value_Terminal);
					gotoIndex = 1;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 0: // <ConfigSettings> ->
					newState.value_Config = Reduce_ConfigSettings_6();
					gotoIndex = 1;
					break;

				case 20: // <Setting> -> Label Assign <SettingValue> Semicolon
					newState.value_Setting = Reduce_Setting_1(stack[stack.Count - 4].value_Terminal, stack[stack.Count - 2].value_Terminal);
					gotoIndex = 1;
					stack.RemoveRange(stack.Count - 4, 4);
					break;

				case 14: // <Setting> -> Label Error Semicolon
					newState.value_Setting = Reduce_Setting_2(stack[stack.Count - 3].value_Terminal, stack[stack.Count - 2].value_Terminal);
					gotoIndex = 1;
					stack.RemoveRange(stack.Count - 3, 3);
					break;

				case 25: // <Using> -> Using Label Assign String Semicolon
					newState.value_Using = Reduce_Using_1(stack[stack.Count - 4].value_Terminal, stack[stack.Count - 2].value_Terminal);
					gotoIndex = 2;
					stack.RemoveRange(stack.Count - 5, 5);
					break;

				case 15: // <Using> -> Using Error Semicolon
					newState.value_Using = Reduce_Using_2(stack[stack.Count - 2].value_Terminal);
					gotoIndex = 2;
					stack.RemoveRange(stack.Count - 3, 3);
					break;

				case 13: // <EntryPoint> -> Entry NonTerminal Semicolon
					newState.value_EntryPoint = Reduce_EntryPoint_1(stack[stack.Count - 2].value_Terminal);
					gotoIndex = 0;
					stack.RemoveRange(stack.Count - 3, 3);
					break;

				case 12: // <EntryPoint> -> Entry Error Semicolon
					newState.value_EntryPoint = Reduce_EntryPoint_2(stack[stack.Count - 2].value_Terminal);
					gotoIndex = 0;
					stack.RemoveRange(stack.Count - 3, 3);
					break;

				case 24: // <Production> -> NonTerminal <ProductionTypeDef> Becomes <RuleList> Semicolon
					newState.value_Production = Reduce_Production_1(stack[stack.Count - 5].value_Terminal, stack[stack.Count - 4].value_Terminal, stack[stack.Count - 2].value_Production);
					gotoIndex = 0;
					stack.RemoveRange(stack.Count - 5, 5);
					break;

				case 10: // <Production> -> NonTerminal Error Semicolon
					newState.value_Production = Reduce_Production_2(stack[stack.Count - 2].value_Terminal);
					gotoIndex = 0;
					stack.RemoveRange(stack.Count - 3, 3);
					break;

				case 16: // <ProductionTypeDef> -> OpenParen Label CloseParen
					newState.value_Terminal = stack[stack.Count - 2].value_Terminal;
					gotoIndex = 0;
					stack.RemoveRange(stack.Count - 3, 3);
					break;

				case 3: // <ProductionTypeDef> ->
					newState.value_Terminal = null;
					gotoIndex = 0;
					break;

				case 27: // <RuleList> -> <RuleList> Pipe <Rule>
					newState.value_Production = Reduce_RuleList_1(stack[stack.Count - 3].value_Production, stack[stack.Count - 1].value_Rule);
					gotoIndex = 2;
					stack.RemoveRange(stack.Count - 3, 3);
					break;

				case 18: // <RuleList> -> <Rule>
					newState.value_Production = Reduce_RuleList_2(stack[stack.Count - 1].value_Rule);
					gotoIndex = 2;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 17: // <Rule> -> <SegmentList>
					newState.value_Rule = stack[stack.Count - 1].value_Rule;
					gotoIndex = 1;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 22: // <Rule> -> <SegmentList> <Command>
					newState.value_Rule = Reduce_Rule_2(stack[stack.Count - 2].value_Rule, stack[stack.Count - 1].value_Command);
					gotoIndex = 1;
					stack.RemoveRange(stack.Count - 2, 2);
					break;

				case 23: // <SegmentList> -> <SegmentList> <Segment>
					newState.value_Rule = Reduce_SegmentList_1(stack[stack.Count - 2].value_Rule, stack[stack.Count - 1].value_Segment);
					gotoIndex = 0;
					stack.RemoveRange(stack.Count - 2, 2);
					break;

				case 19: // <SegmentList> -> Error
					newState.value_Rule = Reduce_SegmentList_2(stack[stack.Count - 1].value_Terminal);
					gotoIndex = 0;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 11: // <SegmentList> ->
					newState.value_Rule = Reduce_SegmentList_3();
					gotoIndex = 0;
					break;

				case 21: // <Segment> -> <RawSegment>
					newState.value_Segment = Reduce_Segment_1(stack[stack.Count - 1].value_Terminal);
					gotoIndex = 1;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 26: // <Segment> -> <RawSegment> <SegmentModifier>
					newState.value_Segment = Reduce_Segment_2(stack[stack.Count - 2].value_Terminal, stack[stack.Count - 1].value_Terminal);
					gotoIndex = 1;
					stack.RemoveRange(stack.Count - 2, 2);
					break;

				case 31: // <Command> -> OpenBrace TargetValue Assign <CommandExpression> Semicolon CloseBrace
					newState.value_Command = stack[stack.Count - 3].value_Command;
					gotoIndex = 0;
					stack.RemoveRange(stack.Count - 6, 6);
					break;

				case 28: // <Command> -> OpenBrace Error CloseBrace
					newState.value_Command = Reduce_Command_2(stack[stack.Count - 2].value_Terminal);
					gotoIndex = 0;
					stack.RemoveRange(stack.Count - 3, 3);
					break;

				case 29: // <CommandExpression> -> ArgumentValue
					newState.value_Command = Reduce_CommandExpression_1(stack[stack.Count - 1].value_Terminal);
					gotoIndex = 0;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 30: // <CommandExpression> -> Null
					newState.value_Command = Reduce_CommandExpression_2(stack[stack.Count - 1].value_Terminal);
					gotoIndex = 0;
					stack.RemoveAt(stack.Count - 1);
					break;

				default: throw new InvalidOperationException("unknown reduction");
			}

			int state = stack[stack.Count - 1].state;
			newState.state = _transitionTable[_transitionTable[state + 57] + gotoIndex];

			stack.Add(newState);

			return newState.state;
		}

		int ReduceError(List<State> stack, IEnumerator<Type_Terminal> enumerator)
		{
			Type_Terminal errorToken = enumerator.Current;

			if (GetTokenType(enumerator.Current) != ConfigTokenType.EOF)
			{
				if (!enumerator.MoveNext())
				{
					throw new InvalidOperationException("ran out of tokens while attempting to recover from a parse error.");
				}
			}

			bool[] failed = new bool[19];

			do
			{
				int state = stack[stack.Count - 1].state;
				int offset = _transitionTable[state];
				int action = offset <= 33 ? offset : _transitionTable[offset + (int)(ConfigTokenType.Error & ColumnMask)];

				if (action == 0 || action > 33)
				{
					break;
				}
				else
				{
					int reductionId = action - 2;
					state = Reduce(reductionId, stack);
				}
			}
			while (true);

			do
			{
				ConfigTokenType nextType = GetTokenType(enumerator.Current);

				if (!failed[(int)(nextType & ColumnMask)])
				{
					for (int i = stack.Count - 1; i >= 0; i--)
					{
						int state = stack[i].state;
						int offset = _transitionTable[state];
						if (offset <= 33) continue;

						int action = _transitionTable[offset + (int)(ConfigTokenType.Error & ColumnMask)] - 33;

						if (action <= 0) continue;
						if (!CanBeFollowedBy(stack, i, action, nextType)) continue;

						State newState = new State();
						newState.state = action;
						newState.value_Terminal = errorToken;

						stack.RemoveRange(i + 1, stack.Count - i - 1);
						stack.Add(newState);
						return action;
					}

					failed[(int)(nextType & ColumnMask)] = true;
				}

				if (nextType == ConfigTokenType.EOF)
				{
					throw new InvalidOperationException("unexpected token: " + GetTokenType(errorToken));
				}
			}
			while (enumerator.MoveNext());

			throw new InvalidOperationException("ran out of tokens while attempting to recover from a parse error.");
		}

		bool CanBeFollowedBy(List<State> stack, int tosIndex, int startState, ConfigTokenType type)
		{
			List<int> overStack = new List<int>();
			overStack.Add(startState);

			int state = startState;

			while (true)
			{
				int offset = _transitionTable[state];
				int action = offset <= 33 ? offset : _transitionTable[offset + (int)(type & ColumnMask)];

				if (action == 0) return false;
				if (action > 33 || action == 1) return true;

				int count;
				int gotoIndex;

				switch (action - 2)
				{
					case 5: // <Config> -> <Config> <Production>
						count = 2;
						gotoIndex = 0;
						break;

					case 4: // <Config> -> <Config> Error
						count = 2;
						gotoIndex = 0;
						break;

					case 1: // <Config> -> <ConfigSettings>
						count = 1;
						gotoIndex = 0;
						break;

					case 8: // <ConfigSettings> -> <ConfigSettings> <Setting>
						count = 2;
						gotoIndex = 1;
						break;

					case 9: // <ConfigSettings> -> <ConfigSettings> <Using>
						count = 2;
						gotoIndex = 1;
						break;

					case 7: // <ConfigSettings> -> <ConfigSettings> <EntryPoint>
						count = 2;
						gotoIndex = 1;
						break;

					case 6: // <ConfigSettings> -> <ConfigSettings> Error
						count = 2;
						gotoIndex = 1;
						break;

					case 2: // <ConfigSettings> -> Error
						count = 1;
						gotoIndex = 1;
						break;

					case 0: // <ConfigSettings> ->
						count = 0;
						gotoIndex = 1;
						break;

					case 20: // <Setting> -> Label Assign <SettingValue> Semicolon
						count = 4;
						gotoIndex = 1;
						break;

					case 14: // <Setting> -> Label Error Semicolon
						count = 3;
						gotoIndex = 1;
						break;

					case 25: // <Using> -> Using Label Assign String Semicolon
						count = 5;
						gotoIndex = 2;
						break;

					case 15: // <Using> -> Using Error Semicolon
						count = 3;
						gotoIndex = 2;
						break;

					case 13: // <EntryPoint> -> Entry NonTerminal Semicolon
						count = 3;
						gotoIndex = 0;
						break;

					case 12: // <EntryPoint> -> Entry Error Semicolon
						count = 3;
						gotoIndex = 0;
						break;

					case 24: // <Production> -> NonTerminal <ProductionTypeDef> Becomes <RuleList> Semicolon
						count = 5;
						gotoIndex = 0;
						break;

					case 10: // <Production> -> NonTerminal Error Semicolon
						count = 3;
						gotoIndex = 0;
						break;

					case 16: // <ProductionTypeDef> -> OpenParen Label CloseParen
						count = 3;
						gotoIndex = 0;
						break;

					case 3: // <ProductionTypeDef> ->
						count = 0;
						gotoIndex = 0;
						break;

					case 27: // <RuleList> -> <RuleList> Pipe <Rule>
						count = 3;
						gotoIndex = 2;
						break;

					case 18: // <RuleList> -> <Rule>
						count = 1;
						gotoIndex = 2;
						break;

					case 17: // <Rule> -> <SegmentList>
						count = 1;
						gotoIndex = 1;
						break;

					case 22: // <Rule> -> <SegmentList> <Command>
						count = 2;
						gotoIndex = 1;
						break;

					case 23: // <SegmentList> -> <SegmentList> <Segment>
						count = 2;
						gotoIndex = 0;
						break;

					case 19: // <SegmentList> -> Error
						count = 1;
						gotoIndex = 0;
						break;

					case 11: // <SegmentList> ->
						count = 0;
						gotoIndex = 0;
						break;

					case 21: // <Segment> -> <RawSegment>
						count = 1;
						gotoIndex = 1;
						break;

					case 26: // <Segment> -> <RawSegment> <SegmentModifier>
						count = 2;
						gotoIndex = 1;
						break;

					case 31: // <Command> -> OpenBrace TargetValue Assign <CommandExpression> Semicolon CloseBrace
						count = 6;
						gotoIndex = 0;
						break;

					case 28: // <Command> -> OpenBrace Error CloseBrace
						count = 3;
						gotoIndex = 0;
						break;

					case 29: // <CommandExpression> -> ArgumentValue
						count = 1;
						gotoIndex = 0;
						break;

					case 30: // <CommandExpression> -> Null
						count = 1;
						gotoIndex = 0;
						break;

					default: throw new InvalidOperationException("unknown reduction");
				}

				if (count >= overStack.Count)
				{
					tosIndex = tosIndex - count + overStack.Count;
					overStack.Clear();

					state = stack[tosIndex].state;
				}
				else if (count > 0)
				{
					overStack.RemoveRange(overStack.Count - count, count);

					state = overStack[overStack.Count - 1];
				}

				overStack.Add(state = _transitionTable[_transitionTable[state + 57] + gotoIndex]);
			}
		}

		static ushort[] Expand(string resourceName)
		{
			using (System.IO.Stream stream = System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceStream(resourceName))
			{
				const byte FOLLOW = 0x80;
				const byte REPEAT = 0x40;
				const byte FIRSTBODY = 0x3F;
				const byte SUBBODY = 0x7F;

				int value;
				byte tmp;

				tmp = unchecked((byte)stream.ReadByte());
				value = tmp & FIRSTBODY;

				while ((tmp & FOLLOW) != 0)
				{
					tmp = unchecked((byte)stream.ReadByte());
					value = (value << 7) | (tmp & SUBBODY);
				}

				int write = 0;
				ushort[] result = new ushort[value];

				while (stream.Position < stream.Length)
				{
					tmp = unchecked((byte)stream.ReadByte());
					if ((tmp & REPEAT) == 0)
					{
						value = tmp & FIRSTBODY;

						while ((tmp & FOLLOW) != 0)
						{
							tmp = unchecked((byte)stream.ReadByte());
							value = (value << 7) | (tmp & SUBBODY);
						}

						result[write++] = unchecked((ushort)value);
					}
					else
					{
						int count = tmp & FIRSTBODY;

						while ((tmp & FOLLOW) != 0)
						{
							tmp = unchecked((byte)stream.ReadByte());
							count = (count << 7) | (tmp & SUBBODY);
						}

						tmp = unchecked((byte)stream.ReadByte());
						value = tmp & FIRSTBODY;

						while ((tmp & FOLLOW) != 0)
						{
							tmp = unchecked((byte)stream.ReadByte());
							value = (value << 7) | (tmp & SUBBODY);
						}

						while (count > 0)
						{
							result[write++] = unchecked((ushort)value);
							count--;
						}
					}
				}

				return result;
			}
		}

		protected abstract ConfigTokenType GetTokenType(Type_Terminal terminal);

		protected abstract Type_Config Reduce_Config_1(Type_Config configSeg, Type_Production productionSeg);
		protected abstract Type_Config Reduce_Config_2(Type_Config configSeg, Type_Terminal errorSeg);
		protected abstract Type_Config Reduce_ConfigSettings_1(Type_Config configSettingsSeg, Type_Setting settingSeg);
		protected abstract Type_Config Reduce_ConfigSettings_2(Type_Config configSettingsSeg, Type_Using usingSeg);
		protected abstract Type_Config Reduce_ConfigSettings_3(Type_Config configSettingsSeg, Type_EntryPoint entryPointSeg);
		protected abstract Type_Config Reduce_ConfigSettings_4(Type_Config configSettingsSeg, Type_Terminal errorSeg);
		protected abstract Type_Config Reduce_ConfigSettings_5(Type_Terminal errorSeg);
		protected abstract Type_Config Reduce_ConfigSettings_6();
		protected abstract Type_Setting Reduce_Setting_1(Type_Terminal labelSeg, Type_Terminal settingValueSeg);
		protected abstract Type_Setting Reduce_Setting_2(Type_Terminal labelSeg, Type_Terminal errorSeg);
		protected abstract Type_Using Reduce_Using_1(Type_Terminal labelSeg, Type_Terminal stringSeg);
		protected abstract Type_Using Reduce_Using_2(Type_Terminal errorSeg);
		protected abstract Type_EntryPoint Reduce_EntryPoint_1(Type_Terminal nonTerminalSeg);
		protected abstract Type_EntryPoint Reduce_EntryPoint_2(Type_Terminal errorSeg);
		protected abstract Type_Production Reduce_Production_1(Type_Terminal nonTerminalSeg, Type_Terminal productionTypeDefSeg, Type_Production ruleListSeg);
		protected abstract Type_Production Reduce_Production_2(Type_Terminal errorSeg);
		protected abstract Type_Production Reduce_RuleList_1(Type_Production ruleListSeg, Type_Rule ruleSeg);
		protected abstract Type_Production Reduce_RuleList_2(Type_Rule ruleSeg);
		protected abstract Type_Rule Reduce_Rule_2(Type_Rule segmentListSeg, Type_Command commandSeg);
		protected abstract Type_Rule Reduce_SegmentList_1(Type_Rule segmentListSeg, Type_Segment segmentSeg);
		protected abstract Type_Rule Reduce_SegmentList_2(Type_Terminal errorSeg);
		protected abstract Type_Rule Reduce_SegmentList_3();
		protected abstract Type_Segment Reduce_Segment_1(Type_Terminal rawSegmentSeg);
		protected abstract Type_Segment Reduce_Segment_2(Type_Terminal rawSegmentSeg, Type_Terminal segmentModifierSeg);
		protected abstract Type_Command Reduce_Command_2(Type_Terminal errorSeg);
		protected abstract Type_Command Reduce_CommandExpression_1(Type_Terminal argumentValueSeg);
		protected abstract Type_Command Reduce_CommandExpression_2(Type_Terminal nullSeg);

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly ushort[] _transitionTable;

		struct State
		{
			public int state;
			public Type_Command value_Command;
			public Type_Config value_Config;
			public Type_EntryPoint value_EntryPoint;
			public Type_Production value_Production;
			public Type_Rule value_Rule;
			public Type_Segment value_Segment;
			public Type_Setting value_Setting;
			public Type_Terminal value_Terminal;
			public Type_Using value_Using;
		}

		static ushort[] GetTransitionTable()
		{
			ushort[] result;

			lock (_weakRef)
			{
				if ((result = (ushort[])_weakRef.Target) == null)
				{
					_weakRef.Target = result = Expand("Buffalo.Core.Parser.Configuration.AutoConfigParser.table");
				}
			}

			return result;
		}

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		static readonly WeakReference _weakRef = new WeakReference(null);
	}
}
