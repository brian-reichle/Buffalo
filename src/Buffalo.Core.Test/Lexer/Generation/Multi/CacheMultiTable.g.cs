// <auto-generated />
//------------------------------------------------------------------------------
// This code is auto-generated.
// Do not attempt to edit this file by hand, you could hurt yourself!
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;

namespace Buffalo.Generated.CacheMultiTable
{
	internal abstract class AutoScanner<TToken> : IEnumerable<TToken>, IEnumerator<TToken>
		where TToken : class
	{
		public enum TokenType : ushort
		{
			EOF = 0,
			StartOther = 1,
			Subtract = 2,
			Multiply = 3,
			Plus = 4,
			Divide = 5,
			OpenParen = 6,
			CloseParen = 7,
			Cat = 8,
			Dog = 9,
			Number = 10,
			Label = 11,
			Whitespace = 12,
			EndOther = 13,
			Label2 = 14,
			Whitespace2 = 15,
		}

		public enum ScannerState
		{
			INITIAL,
			Other,
		}

		// [Statistics Table 0]
		// Char Classifications : 6
		// Char Ranges          : 15
		// States               : 5
		//   Terminal           : 1
		// Transition Table     : 23/30 (76.67%)
		//   Offsets            : 5
		//   Actions            : 18
		// Memory Footprint     : 116 bytes
		//   Boundries          : 30 bytes
		//   Classifications    : 30 bytes
		//   Transitions        : 46 bytes
		//   Token Types        : 10 bytes
		// Assembly Footprint   : 116 bytes (100.00%)

		// [Statistics Table 1]
		// Char Classifications : 19
		// Char Ranges          : 33
		// States               : 20
		//   Terminal           : 7
		// Transition Table     : 156/380 (41.05%)
		//   Offsets            : 20
		//   Actions            : 136
		// Memory Footprint     : 484 bytes
		//   Boundries          : 66 bytes
		//   Classifications    : 66 bytes
		//   Transitions        : 312 bytes
		//   Token Types        : 40 bytes
		// Assembly Footprint   : 362 bytes (74.79%)
		protected AutoScanner(string expressionString)
		{
			_cache = TableCache.Get();
			_expressionString = expressionString;
			_currentState = ScannerState.INITIAL;
			SetForState(ScannerState.INITIAL);
		}

		protected AutoScanner(AutoScanner<TToken> source)
		{
			_cache = source._cache;
			_expressionString = source._expressionString;
			_currentState = ScannerState.INITIAL;
			SetForState(ScannerState.INITIAL);
		}

		~AutoScanner()
		{
			Dispose(false);
		}

		protected abstract TToken NewToken(TokenType type, string expressionString, int startPosition, int length);

		protected virtual AutoScanner<TToken> NewScanner()
		{
			AutoScanner<TToken> result = (AutoScanner<TToken>)MemberwiseClone();
			result._solIndicies = new List<int>();
			result._currentToken = null;
			result._nextCharPosition = 0;
			return result;
		}

		protected void StartOfLine(int charIndex, out int lineNumber, out int charNumber)
		{
			int index = _solIndicies.BinarySearch(charIndex);
			index = index < 0 ? -2 - index : index;

			lineNumber = index + 2;
			charNumber = index < 0 ? charIndex + 1 : charIndex - _solIndicies[index] + 1;
		}

		static ushort[] Extract(string resourceName)
		{
			using (System.IO.Stream stream = System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceStream(resourceName))
			{
				int len = (int)stream.Length;
				ushort[] result = new ushort[len >> 1];
				byte[] buffer = new byte[Math.Min(stream.Length, 512)];
				int offset = 0;
				int read;

				do
				{
					read = stream.Read(buffer, 0, buffer.Length);
					Buffer.BlockCopy(buffer, 0, result, offset, read);
					offset += read;
				}
				while (offset < len && read > 0);

				return result;
			}
		}

		static ushort[] Expand(string resourceName)
		{
			using (System.IO.Stream stream = System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceStream(resourceName))
			using (System.IO.BinaryReader reader = new System.IO.BinaryReader(stream))
			{
				ushort[] result = new ushort[reader.ReadUInt16()];
				ushort escape = reader.ReadUInt16();

				int w = 0;
				while (stream.Position < stream.Length)
				{
					ushort value = reader.ReadUInt16();

					if (value == escape)
					{
						ushort count = reader.ReadUInt16();
						value = reader.ReadUInt16();

						while (count > 0)
						{
							result[w++] = value;
							count--;
						}
					}
					else
					{
						result[w++] = value;
					}
				}

				return result;
			}
		}

		protected ScannerState CurrentState
		{
			[DebuggerStepThrough]
			get { return _currentState; }
		}

		protected void PushState(ScannerState state)
		{
			SetForState(state);
			_state.Push(_currentState);
			_currentState = state;
		}

		protected void PopState()
		{
			if (_state.Count > 0)
			{
				_currentState = _state.Pop();
				SetForState(_currentState);
			}
			else
			{
				throw new InvalidOperationException("State stack is empty");
			}
		}

		void SetForState(ScannerState state)
		{
			switch (state)
			{
				case ScannerState.INITIAL:
					_transitionTable = _cache._transitionTable_1;
					_tokenTypes = _cache._tokenTypes_1;
					_charClassificationBoundries = _cache._charClassificationBoundries_1;
					_charClassification = _cache._charClassification_1;
					break;

				case ScannerState.Other:
					_transitionTable = _cache._transitionTable_0;
					_tokenTypes = _cache._tokenTypes_0;
					_charClassificationBoundries = _cache._charClassificationBoundries_0;
					_charClassification = _cache._charClassification_0;
					break;

				default:
					throw new InvalidOperationException("invalid state");
			}
		}

		int ClassifyChar(char c)
		{
			int lowerBound = 0;
			int upperBound = _charClassificationBoundries.Length;

			while (lowerBound < upperBound)
			{
				int mid = (lowerBound + upperBound) >> 1;

				if (c <= _charClassificationBoundries[mid])
				{
					upperBound = mid;
				}
				else
				{
					lowerBound = mid + 1;
				}
			}

			return _charClassification[lowerBound];
		}

		#region IEnumerable<TToken> Members

		public IEnumerator<TToken> GetEnumerator()
		{
			if (Interlocked.Exchange(ref _started, 1) == 0)
			{
				return this;
			}
			else
			{
				return NewScanner();
			}
		}

		#endregion

		#region IEnumerable Members

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		#endregion

		#region IEnumerator<TToken> Members

		TToken IEnumerator<TToken>.Current
		{
			[DebuggerStepThrough]
			get { return _currentToken; }
		}

		#endregion

		#region IDisposable Members

		void IDisposable.Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool isDisposing)
		{
		}

		#endregion

		#region IEnumerator Members

		object IEnumerator.Current
		{
			[DebuggerStepThrough]
			get { return _currentToken; }
		}

		bool IEnumerator.MoveNext()
		{
			do
			{
				if (_nextCharPosition > _expressionString.Length)
				{
					_currentToken = null;
					return false;
				}
				else if (_nextCharPosition == _expressionString.Length)
				{
					_currentToken = NewToken(TokenType.EOF, _expressionString, _expressionString.Length, 0);

					if (_state.Count > 0)
					{
						PopState();
					}
					else
					{
						_nextCharPosition++;
					}
				}
				else
				{
					int state = 0;
					int startOfNextToken = -1;
					TokenType type = TokenType.EOF;
					int lastSolIndex = _solIndicies.Count > 0 ? _solIndicies[_solIndicies.Count - 1] : 0;

					for (int i = _nextCharPosition; i < _expressionString.Length; i++)
					{
						if (i > lastSolIndex)
						{
							if (_expressionString[i] == '\n' ||
								(_expressionString[i] == '\r' && (i + 1 == _expressionString.Length || _expressionString[i + 1] != '\n')))
							{
								_solIndicies.Add(lastSolIndex = i + 1);
							}
						}

						int offset = _transitionTable[state];

						if (offset == 0 || (state = _transitionTable[offset + ClassifyChar(_expressionString[i])] - 1) == -1)
						{
							break;
						}
						else
						{
							TokenType newType = _tokenTypes[state];

							if (newType != TokenType.EOF)
							{
								type = newType;
								startOfNextToken = i + 1;
							}
						}
					}

					if (type != TokenType.EOF)
					{
						// if end is less than the last value of i then you will end up re-reading some characters,
						// if the start state is the only state that is not an end state then this will never happen.
						_currentToken = NewToken(type, _expressionString, _nextCharPosition, startOfNextToken - _nextCharPosition);
						_nextCharPosition = startOfNextToken;
					}
					else
					{
						// if you write your rules properly then this should never happen.
						// eg. add a rule at the end that matches a single instance of any character.
						throw new InvalidOperationException(string.Format("Got stuck at position {0}.", _nextCharPosition));
					}
				}
			}
			while (_currentToken == null);

			return true;
		}

		void IEnumerator.Reset()
		{
			_currentToken = null;
			_nextCharPosition = 0;
			_solIndicies.Clear();
			_state.Clear();
			_currentState = ScannerState.INITIAL;
			SetForState(ScannerState.INITIAL);
		}

		#endregion

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		TToken _currentToken;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		int _nextCharPosition;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		int _started;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		ScannerState _currentState;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly Stack<ScannerState> _state = new Stack<ScannerState>();
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		List<int> _solIndicies = new List<int>();
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly string _expressionString;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		char[] _charClassificationBoundries;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		ushort[] _charClassification;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		ushort[] _transitionTable;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		TokenType[] _tokenTypes;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly TableCache _cache;

		class TableCache
		{
			protected TableCache()
			{
				_charClassificationBoundries_0 = new char[14]
				{
					'\b', '\r', '\u001f', ' ', '$', '%', '/', '9', '=', '>', '@', 'Z', '`', 'z',
				};
				_charClassification_0 = new ushort[15]
				{
					0, 3, 0, 3, 0, 5, 0, 4, 0, 1, 0, 2, 0, 2, 0,
				};
				_transitionTable_0 = Extract("Buffalo.Core.Test.Lexer.Generation.Multi.CacheMultiTable.0.table");
				_tokenTypes_0 = new TokenType[5]
				{
					TokenType.EOF,
					TokenType.EOF, // [%]
					TokenType.EndOther, // [%][>]
					TokenType.Label2, // [A-Z,a-z]
					TokenType.Whitespace2, // [\t-\r, ]
				};

				_charClassificationBoundries_1 = new char[32]
				{
					'\b', '\r', '\u001f', ' ', '$', '%', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '9',
					';', '<', '@', 'Z', '`', 'a', 'b', 'c', 'd', 'f', 'g', 'n', 'o', 's', 't', 'z',
				};
				_charClassification_1 = new ushort[33]
				{
					0, 5, 0, 5, 0, 14, 0, 16, 3, 1, 17, 0, 18, 4, 2, 9,
					0, 15, 0, 10, 0, 12, 10, 8, 7, 10, 11, 10, 6, 10, 13, 10,
					0,
				};
				_transitionTable_1 = Expand("Buffalo.Core.Test.Lexer.Generation.Multi.CacheMultiTable.1.table");
				_tokenTypes_1 = new TokenType[20]
				{
					TokenType.EOF,
					TokenType.EOF, // [<]
					TokenType.EOF, // [0-9][.]
					TokenType.StartOther, // [<][%]
					TokenType.Subtract, // [-]
					TokenType.Multiply, // [*]
					TokenType.Plus, // [+]
					TokenType.Divide, // [/]
					TokenType.OpenParen, // [(]
					TokenType.CloseParen, // [)]
					TokenType.Cat, // [c][a][t]
					TokenType.Dog, // [d][o][g]
					TokenType.Number, // [0-9][.][0-9]
					TokenType.Number, // [0-9]
					TokenType.Label, // [A-Z,a-b,e-z]
					TokenType.Label, // [d]
					TokenType.Label, // [c][a]
					TokenType.Label, // [d][o]
					TokenType.Label, // [c]
					TokenType.Whitespace, // [\t-\r, ]
				};
			}

			public static TableCache Get()
			{
				TableCache result;

				lock (_weakRef)
				{
					if ((result = (TableCache)_weakRef.Target) == null)
					{
						_weakRef.Target = result = new TableCache();
					}
				}

				return result;
			}

			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			public readonly char[] _charClassificationBoundries_0;
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			public readonly ushort[] _charClassification_0;
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			public readonly ushort[] _transitionTable_0;
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			public readonly TokenType[] _tokenTypes_0;

			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			public readonly char[] _charClassificationBoundries_1;
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			public readonly ushort[] _charClassification_1;
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			public readonly ushort[] _transitionTable_1;
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			public readonly TokenType[] _tokenTypes_1;

			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			static readonly WeakReference _weakRef = new WeakReference(null);
		}
	}
}
