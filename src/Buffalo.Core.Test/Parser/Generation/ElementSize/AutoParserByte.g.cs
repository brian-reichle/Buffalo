// <auto-generated />
//------------------------------------------------------------------------------
// This code is auto-generated.
// Do not attempt to edit this file by hand, you could hurt yourself!
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
using Type_Token = Buffalo.Core.Test.Token;
using Type_Object = System.Object;

namespace Buffalo.Generated.Byte
{
	internal enum TokenType
	{
		Add = 5,
		CloseParen = 4,
		Divide = 0,
		EOF = 9,
		EqualTo = 1,
		GreaterThan = 12,
		GreaterThanOrEqualTo = 2,
		LessThan = 11,
		LessThanOrEqualTo = 3,
		Multiply = 13,
		NotEqualTo = 10,
		Number = 6,
		OpenParen = 7,
		Power = 14,
		Subtract = 8,
	}

	internal abstract class AutoParser
	{
		// [Statistics]
		// Reductions          : 19
		// Terminals           : 15 (15 columns)
		// NonTerminals        : 8 (5 columns)
		// States              : 28
		//   Short Circuited   : 16
		//   With Goto Entries : 11
		//   With SR Conflicts : 4
		//   Other             : 0
		// Transition Table    : 152/560(27.14%)
		//   Primary Offsets   : 28
		//   Goto Offsets      : 11
		//   Actions           : 113
		// Memory Footprint    : 152 bytes
		// Assembly Footprint  : 128 bytes (84.21%)
		protected AutoParser()
		{
			_transitionTable = GetTransitionTable();
		}

		public Type_Object Parse(IEnumerable<Type_Token> tokens)
		{
			return (Type_Object)Parse(tokens, 0).value;
		}

		State Parse(IEnumerable<Type_Token> tokens, int initialState)
		{
			List<State> stack = new List<State>();

			{
				State init = new State();
				init.state = initialState;
				stack.Add(init);
			}

			int state = initialState;

			using (IEnumerator<Type_Token> enumerator = tokens.GetEnumerator())
			{
				bool haveToken = enumerator.MoveNext();

				while (haveToken)
				{
					Type_Token token = enumerator.Current;
					TokenType type = GetTokenType(token);

					{
						int offset = _transitionTable[state];
						int action = offset <= 20 ? offset : _transitionTable[offset + (int)type];

						if (action > 20)
						{
							State newState = new State();
							newState.state = state = action - 20;
							newState.value = token;

							stack.Add(newState);
							haveToken = enumerator.MoveNext();
						}
						else if (action > 1)
						{
							int reductionId = action - 2;
							state = Reduce(reductionId, stack);
						}
						else if (action == 0 || type != TokenType.EOF)
						{
							UnexpectedToken(token);
							throw new InvalidOperationException("unexpected token: " + type);
						}
						else
						{
							return stack[1];
						}
					}
				}
			}

			throw new InvalidOperationException("ran out of tokens, somehow");
		}

		int Reduce(int reductionId, List<State> stack)
		{
			State newState = new State();
			int gotoIndex;

			switch (reductionId)
			{
				case 14: // <Equation> -> <Expression> <ComparisonOp> <Expression>
					newState.value = Reduce_Equation_1((Type_Object)stack[stack.Count - 3].value, (Type_Object)stack[stack.Count - 2].value, (Type_Object)stack[stack.Count - 1].value);
					gotoIndex = 4;
					stack.RemoveRange(stack.Count - 3, 3);
					break;

				case 4: // <ComparisonOp> -> EqualTo
					newState.value = Reduce_ComparisonOp_1((Type_Token)stack[stack.Count - 1].value);
					gotoIndex = 1;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 9: // <ComparisonOp> -> NotEqualTo
					newState.value = Reduce_ComparisonOp_2((Type_Token)stack[stack.Count - 1].value);
					gotoIndex = 1;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 7: // <ComparisonOp> -> LessThan
					newState.value = Reduce_ComparisonOp_3((Type_Token)stack[stack.Count - 1].value);
					gotoIndex = 1;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 8: // <ComparisonOp> -> LessThanOrEqualTo
					newState.value = Reduce_ComparisonOp_4((Type_Token)stack[stack.Count - 1].value);
					gotoIndex = 1;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 5: // <ComparisonOp> -> GreaterThan
					newState.value = Reduce_ComparisonOp_5((Type_Token)stack[stack.Count - 1].value);
					gotoIndex = 1;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 6: // <ComparisonOp> -> GreaterThanOrEqualTo
					newState.value = Reduce_ComparisonOp_6((Type_Token)stack[stack.Count - 1].value);
					gotoIndex = 1;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 15: // <Expression> -> <Expression> <TermOp> <Term>
					newState.value = Reduce_Expression_1((Type_Object)stack[stack.Count - 3].value, (Type_Object)stack[stack.Count - 2].value, (Type_Object)stack[stack.Count - 1].value);
					gotoIndex = 3;
					stack.RemoveRange(stack.Count - 3, 3);
					break;

				case 0: // <Expression> -> <Term>
					newState.value = Reduce_Expression_2((Type_Object)stack[stack.Count - 1].value);
					gotoIndex = 3;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 10: // <TermOp> -> Add
					newState.value = Reduce_TermOp_1((Type_Token)stack[stack.Count - 1].value);
					gotoIndex = 0;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 11: // <TermOp> -> Subtract
					newState.value = Reduce_TermOp_2((Type_Token)stack[stack.Count - 1].value);
					gotoIndex = 0;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 16: // <Term> -> <Term> <FactorOp> <Factor>
					newState.value = Reduce_Term_1((Type_Object)stack[stack.Count - 3].value, (Type_Object)stack[stack.Count - 2].value, (Type_Object)stack[stack.Count - 1].value);
					gotoIndex = 2;
					stack.RemoveRange(stack.Count - 3, 3);
					break;

				case 2: // <Term> -> <Factor>
					newState.value = Reduce_Term_2((Type_Object)stack[stack.Count - 1].value);
					gotoIndex = 2;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 13: // <FactorOp> -> Multiply
					newState.value = Reduce_FactorOp_1((Type_Token)stack[stack.Count - 1].value);
					gotoIndex = 0;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 12: // <FactorOp> -> Divide
					newState.value = Reduce_FactorOp_2((Type_Token)stack[stack.Count - 1].value);
					gotoIndex = 0;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 17: // <Factor> -> <Value> Power <Value>
					newState.value = Reduce_Factor_1((Type_Object)stack[stack.Count - 3].value, (Type_Token)stack[stack.Count - 2].value, (Type_Object)stack[stack.Count - 1].value);
					gotoIndex = 1;
					stack.RemoveRange(stack.Count - 3, 3);
					break;

				case 1: // <Factor> -> <Value>
					newState.value = Reduce_Factor_2((Type_Object)stack[stack.Count - 1].value);
					gotoIndex = 1;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 3: // <Value> -> Number
					newState.value = Reduce_Value_1((Type_Token)stack[stack.Count - 1].value);
					gotoIndex = 0;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 18: // <Value> -> OpenParen <Expression> CloseParen
					newState.value = Reduce_Value_2((Type_Token)stack[stack.Count - 3].value, (Type_Object)stack[stack.Count - 2].value, (Type_Token)stack[stack.Count - 1].value);
					gotoIndex = 0;
					stack.RemoveRange(stack.Count - 3, 3);
					break;

				default: throw new InvalidOperationException("unknown reduction");
			}

			int state = stack[stack.Count - 1].state;
			newState.state = _transitionTable[_transitionTable[state + 28] + gotoIndex];

			stack.Add(newState);

			return newState.state;
		}

		protected virtual void UnexpectedToken(Type_Token terminal)
		{
		}

		static byte[] Expand(string resourceName)
		{
			using (System.IO.Stream stream = System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceStream(resourceName))
			using (System.IO.BinaryReader reader = new System.IO.BinaryReader(stream))
			{
				byte[] result = new byte[reader.ReadByte()];
				byte escape = reader.ReadByte();

				int w = 0;
				while (stream.Position < stream.Length)
				{
					byte value = reader.ReadByte();

					if (value == escape)
					{
						byte count = reader.ReadByte();
						value = reader.ReadByte();

						while (count > 0)
						{
							result[w++] = value;
							count--;
						}
					}
					else
					{
						result[w++] = value;
					}
				}

				return result;
			}
		}

		protected abstract TokenType GetTokenType(Type_Token terminal);

		protected abstract Type_Object Reduce_Equation_1(Type_Object expressionSeg1, Type_Object comparisonOpSeg, Type_Object expressionSeg2);
		protected abstract Type_Object Reduce_ComparisonOp_1(Type_Token equalToSeg);
		protected abstract Type_Object Reduce_ComparisonOp_2(Type_Token notEqualToSeg);
		protected abstract Type_Object Reduce_ComparisonOp_3(Type_Token lessThanSeg);
		protected abstract Type_Object Reduce_ComparisonOp_4(Type_Token lessThanOrEqualToSeg);
		protected abstract Type_Object Reduce_ComparisonOp_5(Type_Token greaterThanSeg);
		protected abstract Type_Object Reduce_ComparisonOp_6(Type_Token greaterThanOrEqualToSeg);
		protected abstract Type_Object Reduce_Expression_1(Type_Object expressionSeg, Type_Object termOpSeg, Type_Object termSeg);
		protected abstract Type_Object Reduce_Expression_2(Type_Object termSeg);
		protected abstract Type_Object Reduce_TermOp_1(Type_Token addSeg);
		protected abstract Type_Object Reduce_TermOp_2(Type_Token subtractSeg);
		protected abstract Type_Object Reduce_Term_1(Type_Object termSeg, Type_Object factorOpSeg, Type_Object factorSeg);
		protected abstract Type_Object Reduce_Term_2(Type_Object factorSeg);
		protected abstract Type_Object Reduce_FactorOp_1(Type_Token multiplySeg);
		protected abstract Type_Object Reduce_FactorOp_2(Type_Token divideSeg);
		protected abstract Type_Object Reduce_Factor_1(Type_Object valueSeg1, Type_Token powerSeg, Type_Object valueSeg2);
		protected abstract Type_Object Reduce_Factor_2(Type_Object valueSeg);
		protected abstract Type_Object Reduce_Value_1(Type_Token numberSeg);
		protected abstract Type_Object Reduce_Value_2(Type_Token openParenSeg, Type_Object expressionSeg, Type_Token closeParenSeg);

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly byte[] _transitionTable;

		struct State
		{
			public int state;
			public object value;
		}

		static byte[] GetTransitionTable()
		{
			return Expand("Buffalo.Core.Test.Parser.Generation.ElementSize.AutoParserByte.table");
		}
	}
}
