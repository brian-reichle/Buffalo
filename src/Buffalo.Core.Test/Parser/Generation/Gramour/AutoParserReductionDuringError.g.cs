// <auto-generated />
//------------------------------------------------------------------------------
// This code is auto-generated.
// Do not attempt to edit this file by hand, you could hurt yourself!
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
using Type_Segment = System.String;
using Type_Token = Buffalo.Core.Test.Token;

namespace Buffalo.Generated.ReductionDuringError
{
	internal enum TokenType
	{
		EOF = 1,
		Error = 3,
		x = 0,
		y = 2,
	}

	internal abstract class AutoParser
	{
		// [Statistics]
		// Reductions          : 9
		// Terminals           : 4 (4 columns)
		// NonTerminals        : 6 (3 columns)
		// States              : 14
		//   Short Circuited   : 8
		//   With Goto Entries : 6
		//   With SR Conflicts : 6
		//   Other             : 0
		// Transition Table    : 41/98(41.84%)
		//   Primary Offsets   : 14
		//   Goto Offsets      : 6
		//   Actions           : 21
		// Memory Footprint    : 82 bytes
		// Assembly Footprint  : 82 bytes (100.00%)
		protected AutoParser()
		{
			_transitionTable = GetTransitionTable();
		}

		public Type_Segment Parse(IEnumerable<Type_Token> tokens)
		{
			return (Type_Segment)Parse(tokens, 0).value;
		}

		State Parse(IEnumerable<Type_Token> tokens, int initialState)
		{
			List<State> stack = new List<State>();

			{
				State init = new State();
				init.state = initialState;
				stack.Add(init);
			}

			int state = initialState;

			using (IEnumerator<Type_Token> enumerator = tokens.GetEnumerator())
			{
				bool haveToken = enumerator.MoveNext();

				while (haveToken)
				{
					Type_Token token = enumerator.Current;
					TokenType type = GetTokenType(token);

					if (type == TokenType.Error)
					{
						state = ReduceError(stack, enumerator);
					}
					else
					{
						int offset = _transitionTable[state];
						int action = offset <= 10 ? offset : _transitionTable[offset + (int)type];

						if (action > 10)
						{
							State newState = new State();
							newState.state = state = action - 10;
							newState.value = token;

							stack.Add(newState);
							haveToken = enumerator.MoveNext();
						}
						else if (action > 1)
						{
							int reductionId = action - 2;
							state = Reduce(reductionId, stack);
						}
						else if (action == 0 || type != TokenType.EOF)
						{
							state = ReduceError(stack, enumerator);
						}
						else
						{
							return stack[1];
						}
					}
				}
			}

			throw new InvalidOperationException("ran out of tokens, somehow");
		}

		int Reduce(int reductionId, List<State> stack)
		{
			State newState = new State();
			int gotoIndex;

			switch (reductionId)
			{
				case 7: // <Test> -> <A> <B> <C>
					newState.value = Reduce_Test_1((Type_Segment)stack[stack.Count - 3].value, (Type_Segment)stack[stack.Count - 2].value, (Type_Segment)stack[stack.Count - 1].value);
					gotoIndex = 1;
					stack.RemoveRange(stack.Count - 3, 3);
					break;

				case 5: // <A> -> <X> <Y>
					newState.value = Reduce_A_1((Type_Segment)stack[stack.Count - 2].value, (Type_Segment)stack[stack.Count - 1].value);
					gotoIndex = 2;
					stack.RemoveRange(stack.Count - 2, 2);
					break;

				case 6: // <B> -> <X> <Y>
					newState.value = Reduce_B_1((Type_Segment)stack[stack.Count - 2].value, (Type_Segment)stack[stack.Count - 1].value);
					gotoIndex = 1;
					stack.RemoveRange(stack.Count - 2, 2);
					break;

				case 8: // <C> -> <X> <Y>
					newState.value = Reduce_C_1((Type_Segment)stack[stack.Count - 2].value, (Type_Segment)stack[stack.Count - 1].value);
					gotoIndex = 1;
					stack.RemoveRange(stack.Count - 2, 2);
					break;

				case 3: // <X> -> x
					newState.value = Reduce_X_1((Type_Token)stack[stack.Count - 1].value);
					gotoIndex = 0;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 2: // <X> -> Error
					newState.value = Reduce_X_2((Type_Token)stack[stack.Count - 1].value);
					gotoIndex = 0;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 0: // <X> ->
					newState.value = Reduce_X_3();
					gotoIndex = 0;
					break;

				case 4: // <Y> -> y
					newState.value = Reduce_Y_1((Type_Token)stack[stack.Count - 1].value);
					gotoIndex = 0;
					stack.RemoveAt(stack.Count - 1);
					break;

				case 1: // <Y> ->
					newState.value = Reduce_Y_2();
					gotoIndex = 0;
					break;

				default: throw new InvalidOperationException("unknown reduction");
			}

			int state = stack[stack.Count - 1].state;
			newState.state = _transitionTable[_transitionTable[state + 14] + gotoIndex];

			stack.Add(newState);

			return newState.state;
		}

		int ReduceError(List<State> stack, IEnumerator<Type_Token> enumerator)
		{
			Type_Token errorToken = enumerator.Current;

			if (GetTokenType(enumerator.Current) != TokenType.EOF)
			{
				if (!enumerator.MoveNext())
				{
					throw new InvalidOperationException("ran out of tokens while attempting to recover from a parse error.");
				}
			}

			bool[] failed = new bool[4];

			do
			{
				int state = stack[stack.Count - 1].state;
				int offset = _transitionTable[state];
				int action = offset <= 10 ? offset : _transitionTable[offset + (int)TokenType.Error];

				if (action == 0 || action > 10)
				{
					break;
				}
				else
				{
					int reductionId = action - 2;
					state = Reduce(reductionId, stack);
				}
			}
			while (true);

			do
			{
				TokenType nextType = GetTokenType(enumerator.Current);

				if (!failed[(int)nextType])
				{
					for (int i = stack.Count - 1; i >= 0; i--)
					{
						int state = stack[i].state;
						int offset = _transitionTable[state];
						if (offset <= 10) continue;

						int action = _transitionTable[offset + (int)TokenType.Error] - 10;

						if (action <= 0) continue;
						if (!CanBeFollowedBy(stack, i, action, nextType)) continue;

						State newState = new State();
						newState.state = action;
						newState.value = errorToken;

						stack.RemoveRange(i + 1, stack.Count - i - 1);
						stack.Add(newState);
						return action;
					}

					failed[(int)nextType] = true;
				}

				if (nextType == TokenType.EOF)
				{
					throw new InvalidOperationException("unexpected token: " + GetTokenType(errorToken));
				}
			}
			while (enumerator.MoveNext());

			throw new InvalidOperationException("ran out of tokens while attempting to recover from a parse error.");
		}

		bool CanBeFollowedBy(List<State> stack, int tosIndex, int startState, TokenType type)
		{
			List<int> overStack = new List<int>();
			overStack.Add(startState);

			int state = startState;

			while (true)
			{
				int offset = _transitionTable[state];
				int action = offset <= 10 ? offset : _transitionTable[offset + (int)type];

				if (action == 0) return false;
				if (action > 10 || action == 1) return true;

				int count;
				int gotoIndex;

				switch (action - 2)
				{
					case 7: // <Test> -> <A> <B> <C>
						count = 3;
						gotoIndex = 1;
						break;

					case 5: // <A> -> <X> <Y>
						count = 2;
						gotoIndex = 2;
						break;

					case 6: // <B> -> <X> <Y>
						count = 2;
						gotoIndex = 1;
						break;

					case 8: // <C> -> <X> <Y>
						count = 2;
						gotoIndex = 1;
						break;

					case 3: // <X> -> x
						count = 1;
						gotoIndex = 0;
						break;

					case 2: // <X> -> Error
						count = 1;
						gotoIndex = 0;
						break;

					case 0: // <X> ->
						count = 0;
						gotoIndex = 0;
						break;

					case 4: // <Y> -> y
						count = 1;
						gotoIndex = 0;
						break;

					case 1: // <Y> ->
						count = 0;
						gotoIndex = 0;
						break;

					default: throw new InvalidOperationException("unknown reduction");
				}

				if (count >= overStack.Count)
				{
					tosIndex = tosIndex - count + overStack.Count;
					overStack.Clear();

					state = stack[tosIndex].state;
				}
				else if (count > 0)
				{
					overStack.RemoveRange(overStack.Count - count, count);

					state = overStack[overStack.Count - 1];
				}

				overStack.Add(state = _transitionTable[_transitionTable[state + 14] + gotoIndex]);
			}
		}

		static ushort[] Extract(string resourceName)
		{
			using (System.IO.Stream stream = System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceStream(resourceName))
			{
				int len = (int)stream.Length;
				ushort[] result = new ushort[len >> 1];
				byte[] buffer = new byte[Math.Min(stream.Length, 512)];
				int offset = 0;
				int read;

				do
				{
					read = stream.Read(buffer, 0, buffer.Length);
					Buffer.BlockCopy(buffer, 0, result, offset, read);
					offset += read;
				}
				while (offset < len && read > 0);

				return result;
			}
		}

		protected abstract TokenType GetTokenType(Type_Token terminal);

		protected abstract Type_Segment Reduce_Test_1(Type_Segment aSeg, Type_Segment bSeg, Type_Segment cSeg);
		protected abstract Type_Segment Reduce_A_1(Type_Segment xSeg, Type_Segment ySeg);
		protected abstract Type_Segment Reduce_B_1(Type_Segment xSeg, Type_Segment ySeg);
		protected abstract Type_Segment Reduce_C_1(Type_Segment xSeg, Type_Segment ySeg);
		protected abstract Type_Segment Reduce_X_1(Type_Token xSeg);
		protected abstract Type_Segment Reduce_X_2(Type_Token errorSeg);
		protected abstract Type_Segment Reduce_X_3();
		protected abstract Type_Segment Reduce_Y_1(Type_Token ySeg);
		protected abstract Type_Segment Reduce_Y_2();

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly ushort[] _transitionTable;

		struct State
		{
			public int state;
			public object value;
		}

		static ushort[] GetTransitionTable()
		{
			return Extract("Buffalo.Core.Test.Parser.Generation.Gramour.AutoParserReductionDuringError.table");
		}
	}
}
